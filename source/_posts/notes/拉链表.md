### 一、拉链表

业务库有一些表，例如用户表，它的数据量非常大，而且每日会有新、修改的数据，但是每日变化的量级很小。这种我们称为 **缓慢变化维度**（SCD，Slowly Changing Dimension）。如果全量同步，大数据量下对业务库的压力很大。而每日新增和变化（upsert）的数据量可控，那么如果增量同步，增量数据和存量快照合并得到最新数据库的快照。

所谓拉链表就是在原始数据域的基础上，增加两个字段，一个用来表示记录开始的字段  start_date，另一个用来标识结束时间 end_date。 如果记录仍然有效，结束时间可以设置为一个未来的日期或特定的标志值 (9999-12-31 或 null）。

例如拉链表：

| user_id| name | phone      | start_date  | end_date    |
|--------|------|------------|-----------|-------------|
| 1      | 张三 | 136****9090 | 2019-01-01 | 2019-01-01 |
| 1      | 张三 | 137****8989 | 2019-01-02 | 2019-01-09 |
| 1      | 张三 | 147****1234 | 2019-01-10 | 9999-12-31 |


它在时间轴的含义是：

```sql
                                                                ┌──────────────┬───────────┬──────────┐
                                                                │col1          │ start_date│end_date  │
                                                                ├──────────────┼───────────┼──────────┤
                                                                │id=1|name=john│ 2019-01-10│9999-12-31│
                                                                └──────────────┴───────────┴──────────┘
                                ┌──────────────┬───────────┬──────────┐                         |                        
                                │col1          │ start_date│end_date  │                         |    
                                ├──────────────┼───────────┼──────────┤                         |   
                                │id=1|name=john│ 2019-01-02│2019-01-09│                         |        
                                └──────────────┴───────────┴──────────┘                         | 
                                                                                                |
    ┌──────────────┬───────────┬──────────┐                                                     |   
    │col1          │ start_date│end_date  │                                                     |
    ├──────────────┼───────────┼──────────┤                                                     |
    │id=1|name=john│ 2019-01-01│2019-01-01│                                                     |
    └──────────────┴───────────┴──────────┘                                                     |
                         |                                                                      |  
                         |                                                                      |
                         |                                                                      |
                         |                                                                      |
                         |                                                                      |
                         |                                                                      |
------------------------------------------------------------------------------------------------------------------> 时间轴
                    start_date                                                              end_date

                                    <=   日期左区间                       日期右区间   <=

```

比如我要拿到， 在 2019-01-05 到 2019-01-10 期间的用户手机变化历史，则 用表达式  `where 2019-01-05 >=  start_date and 2019-01-10 < end_date `来查询。

也就是历史切片公式：
```sql
where 目标日期>=begin_dt and 目标日期 < end_dt
```


**分区：**
在 Hive 或数据仓库，一般会对表分区，形成 9999 分区 和 每日历史分区。
```sql
            +-----------+       +------------+   +------------+
            | 9999-12-31|       | 2021-01-01 |   | 2021-01-02 |    .....
            +-----------+       +------------+   +------------+
```

其中，9999-12-31 分区存放最新数据，和业务库保证 T+1 一致。历史分区存放合并产生的过期数据，按照 end_date 分区。 
> 也有重新构造分区字段 dt，但是用 end_date 作为分区字段更加直观。



**1. 新增或更新数据：**

每日新增或变化的数据，start_date 就是当天同步的日期（调度日期），end_date 可以设为 日期最大值 或者空值。

```sql
insert 或 update 
      {( 数据域 ) , (start_date = 调度日期， end_date = 9999-12-31)}
```

- end_date 为 9999-12-31 表示该数据是最新的数据，没有过期。数据来源可能是新增，也可能是更新。
- 调度日期就是该条数据产生的日期。
- 某些教程会称这条数据为 **开链** 数据。


**2. 历史数据：**

```sql
     {( 数据域 ) , (start_date = 历史调度日期， end_date = 当日调度日期)}
```
-  （start_date，end_date）表示该条数据的有效时间范围。这条数据标识过期数据。

### 二、拉链表的加载，更新策略

拉链表要求：
1. 有一张维度基表，且该基表是增量更新策略，也就是 Base + incr 更新方式。 incr 每日同步新增和变化的数据。
2. 每条数据必须有一个业务主键。

概括来说 维度基表用 base + incr方式，初始用base做一个scd表， 然后每天用scd + incr更新； 重跑的话直接用base + 截至日期的全量incr 。
具体就是： 将 昨日全量数据（9999分区） 和 今日upsert数据（incr）做 FULL JOIN，得到四部分数据，然后分别处理。

```text
                                                ODS 增量数据（Delta） 
                                                 +-----------------+        
                                                 |                 | 
                                                 |                 |  <-- 左边独有：新增数据（没有关联上的）     
 +---------------------------------------------- |                 |
 |                                               |                 |
 |                                               |                 |
 |                                               |                 |           拉链表昨日最新分区 (9999-12-31)
 |                                               |- - - - - - - - - - - - - -  +----------+++-------+
 |                                               |                 |           |                    |
 |                                               |                 |           |                    |  <-- ：右边关联上的数据：过期数据
 |                                               |                 |           |                    |
 |                                               |                 |           |                    |----------------------------------------------+
 |                                               |                 |           |                    |                                              |
 |           左关联上的，数据域update的  <----------|                 |   key     |                    |                                              | 
 |                                        |      |                 | fulljoin  |                    |                                              |
 |                                        |      |                 |           |                    |                                              |
 |                                        |      |                 |           |                    |                                              |
 |                                        |      |                 |           |                    |                                              |
 |                                        |      |                 |           |                    |                                              |
 |                                        |      +-----------------+- - - - - - - - - - - - - - - - |                                              |
 |                                        |                                    |                    |                                              |
 |                                        |                                    |                    |                                              |
 |                                        |                                    |                    |                                              |
 |                                        |                                    |                    |                                              |
 |                                        |                                    |                    |                                              |
 |                                        |                                    |                    |   <-- 右边独有：老数据（无需变动）                |
 |                                        |                 +----------------  |                    |                                              |
 |                                        |                 |                  |                    |                                              |
 |                                        |                 |                  |                    |                                              |
 |                                        |                 |                  |                    |                                              |
 |                                        |                 |                  +--------------------+                                              |
 |                                        |                 |                                                                                      |
 |                                        |                 |                                     +-------------------------------------------------+
 |----------------------------+           |                 |                                     |
                              |           |                 |                                     |
                              |          \/                \/                                    \/
                        |     \/        9999分区                                           |    当日历史分区       |
                        +-----------------------------------------------------------------+---------------------+
                        |                                                                 |                     |
                        |                                                                 |                     |
                        |                                                                 |                     |
                        +---------------------------------------------------   -----------+---------------------+
```

这四部分数据为：

- **左表独有的数据**   ：是新增数据，入 9999-12-31 分区。 时间区间赋值：

```sql
（数据域）, (start_date = 当日调度日期， end_date = 9999-12-31)
```

- **右表独有的数据** ： 是没有任何变化的数据，入到 9999-12-31 分区。 数据域不变，时间区间不变。


- **左表关联上的**  ： 是 update 的数据，入 9999-12-31 分区。 时间区间赋值：

```sql
 
（取 ODS Incr 数据域）, (start_date = 调度日期， end_date = 9999-12-31)
```

- **右表关联上的** ： 是过期数据，入到当日历史分区。 时间区间赋值：

```sql
（取 9999-12-31 数据域）, (start_date = old.start_date, end_date = 当日调度日期)
```

从 入拉链表分区来看，可以分为入 9999-12-31 分区 和 入历史分区两部分。这两部分数据特征是 ：

**1. 新增或更新数据：**
每日新增或变化的数据，start_date 就是当天同步的日期（调度日期），end_date 可以设为 日期最大值 或者空值。

```sql
insert 或 update 
      {( 数据域 ) , (start_date = 调度日期， end_date = 9999-12-31)}
```
因为这部分要对 左区间赋值，所以有人称为这个操作称为开链操作， 这些新增及变化的数据称为开链数据。

- end_date 为 9999-12-31 表示该数据是最新的数据，没有过期。数据来源可能是新增，也可能是更新。
- 调度日期就是该条数据产生的日期。
- 某些教程会称这条数据为 **开链** 数据。
- 
**2. 历史数据：**

```sql
     {( 数据域 ) , (start_date = 历史调度日期， end_date = 当日调度日期)}
```
因为过期数要要标识左右区间数据，所以有人称为这个操作称为闭链操作， 这些过期数据称为闭链数据。

#### 三、具体实现：

#### 4.1 方法一
```sql
-- 方法一: left join + union all写法
insert overwrite dwd.user_zipper partition (end_dt)
    select
         id
        ,user_id
        ,balance_amt
        ,begin_dt
        ,end_dt
    from(
        select
             t1.id
            ,t1.user_id
            ,t1.balance_amt
            ,t1.begin_dt
            ,if(t2.id is not null, '调度日期', '9999-12-31') as end_dt
        from(--昨日全量数据
            select *
            from dwd_user_balance_zip
            where end_dt = '9999-12-31'
        )t1 
        left join(--今日的upsert数据
            select id
            from ODS_Delta
        )t2 on t1.id = t2.id

        union all 

        select -- 今日的upsert数据
             id
            ,user_id
            ,balance_amt
            ,'调度日期'             as begin_dt
            ,'9999-12-31'           as end_dt
        from ODS_Delta
    )t1
```


这个思路是，先取 9999 分区的全部数据，没有关联上的数据入 9999 分区，关联上的数据入 调度日期。然后 今日upsert数据全入 9999 分区。

这个思路核心是：
1. 今日 upsert数据 处理策略是： 数据域不变，全入 9999 分区。
```
(数据域) , (start_date = 调度日期， end_date = 9999-12-31)
```
1. 9999 分区的数据处理策略是： 通过对end_date的赋值控制两部分数据进入对应分区。 没有关联上的，也就是无变化的入 9999 分区，有变化的数据入调度日期分区。
```
-- 无变化的数据
(数据域) , (start_date = 不变， end_date = 9999-12-31)
-- 有变化的数据
(数据域) , (start_date = 不变， end_date = 调度日期)
```

```                                                         昨日全量（9999-12-31）数据
                                                            +-----------------+
                                                            |                 |
                       入 9999 分区，         <------------- |                 |
        start_date = 不变， end_date = 9999-12-31）          |                 |
                                                            |                 |
                                                            | - - - - - - - - |        今日 upsert数据
                                                            |                 |    +-----------------+
                                                            |                 |    |                 |
                      入 历史分区                             |                 |    |                 |
              start_date= 不变   end_date = 9999 <---------- |                 |    |                 |
                                                            |                 |    |                 |
                                                            +-----------------+    |                 |  --> 9999 分区  （start_date = 调度日期， end_date = 9999-12-31）
                                                                                   |                 |
                                                                                   |                 |
                                                                                   |                 |
                                                                                   |                 |
                                                                                   +-----------------+
```

#### 4.2 方法二 full join
```sql
--方法三: full join写法(某机构的一个写法)
    with tmp as (
        select
            old.*
            ,new.*
        from( 
            select 
                *
            from 拉链表
            where end_dt = '3000-12-31'
        )old
        full join(--今日的update数据
            select *
            from 新增数据表
        )new on old.id = new.id
    )
    ;


    insert overwrite dwd_user_balance_zip
        partition (end_dt)
    select
        coalesce(new.id, old.id)                        as id
        ,coalesce(new.user_id, old.user_id)             as user_id
        ,coalesce(new.balance_amt, old.balance_amt)          as balance_amt
        ,case 
            when new.id is not null then '调度日'
            when new.id is null and old.id is not null then old.begin_dt
        end                                             as begin_dt
        ,'3000-12-31' as end_dt
    from tmp

    union a
    select
         old.id                        as id
        ,old.user_id             as user_id
        ,old.balance_amt          as balance_amt
        ,old.begin_dt
        ,'调度日' as end_dt
    from tmp
    where new.id is not null and old.id is not null
```

这个思路是 ：
- 入9999 分区数据有哪些？ 入 9999 分区有两块，今日upsert数据（今日新增， 今日变化） 和 无变化的数据（ 9999 分区独有的数据）。  也就是先处理开链数据。
- 入历史数据分区有哪些 ？ 昨日全量9999 分区 中关联上的部分。 也就是处理闭链数据。 


#### 4.3 方法三 开窗方式
```sql
insert overwrite table dim_user_zip partition (dt)
select *
       start_date,
       if(rn = 2, date_sub('2022-06-09', 1), end_date)     end_date,
       if(rn = 1, '9999-12-31', date_sub('2022-06-09', 1)) dt   --- 这个dt 逻辑可以和end_date一致，更加简洁
from (
         select *
                start_date,
                end_date,
                row_number() over (partition by id order by start_date desc) rn
         from (

                  select *   -- 昨日全量数据
                         start_date,
                         end_date
                  from dim_user_zip
                  where dt = '9999-12-31'

                  union all

                  select *        --- 今日upsert数据
                         '2022-06-09'                                   start_date,
                         '9999-12-31'                                   end_date
                  from ods_user_info_inc 
              ) t1
     ) t2;
```
这个思路是， union all后， 左右两表独有的数据，窗口只可能有一条数据， 通过rn = 1 区分， 中间重合的部分，窗口有两条数据，rn =  1是新的， rn = 2 是过期数据。


- 这些实现思路核心思路无外乎就是如何区分 四部分的数据。
- 注意 start_date 和 end_date 的赋值逻辑， 对于 start_date , 新增及变化的数据就为 调度日期， 无变化的数据就为不变。 对于 end_date， 新增及变化的数据、无变化的数据 就为 9999-12-31， 过期数据就是 调度日期。




#### 重跑幂等

拉链表每日更新会 9999 分区 和 昨日历史分区。 如果重跑，需要恢复到上一次跑批9999 分区状态，当前 9999 历史分区都是多了哪些数据？
- 9999 分区 ： 今日insert 数据， 今日 update数据
- 昨日历史分区： 今日update数据，也就是过期数据

取 9999 分区时候，指定限制条件为

```sql
where begin_dt < '调度日期' --重跑时, 过滤掉了最大分区里面, 今天已改变的数据, 
            and end_dt >= '调度日期'    --重跑时, 取出调度日分区, 当天已经'结束'的数据 
```
思路是 先用  `begin_dt < '调度日期'` 干掉今日变化的数据，但是还有一部分今日update数据也被干掉了，然后再用 `end_dt >= '调度日期'` 取出调度日分区，当天已经'结束'的数据。


如果要重跑某日数据，改为当日调度日，然后**串行**跑之后的**所有的分区**。

这种方案是从 拉链表 中恢复， 需要严格限制start_date 和 end_date 的范围。

还有一种策略是使用 维度基表， 维度基表是 Base + incr 表，  重跑拉链表直接， 用 Base + 截至日期的 incr 表，借助窗口函数写法很容易改造，但是这样有一个风险会更新全部历史分区数据 + 9999 分区数据。
折中办法是，使用 Base + 截至日期的 incr 表 构造 昨日全量数据（9999分区）。


例子 ：
   https://github.com/Grebeci/CaseCode/blob/main/bigdata/zipper_table.txt


【参考资料】 ：
    https://note.youdao.com/ynoteshare/index.html?id=8ab8446b3427cc209d07756360ddb887&type=note&_time=1742572856461 
    B站视频 https://www.bilibili.com/video/BV1LJ4m1u7jj?spm_id_from=333.788.recommend_more_video.1&vd_source=b820ad274d9cfbd9b19967441f219fa7
    视频笔记 ： 
          https://www.bilibili.com/video/BV1LJ4m1u7jj?t=847.2 
          重炮时候，create的数据也会受影响。